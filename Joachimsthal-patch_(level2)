"""
GhPython component (Rhino 8)

Inputs (name : type):
- V_str : text          # expression in 'v' (e.g., "v", "sin(v)", "cos(v/2)+1", etc.)
- U     : list of float # u-samples (u1)
- V     : list of float # v-samples (v1)

Output:
- Pts   : list[list[Rhino.Geometry.Point3d]]  # grid with len(V) rows and len(U) columns
"""

import math
import Rhino.Geometry as rg

# ---------- safe evaluator for V(v) ----------
_SAFE = {
    'sin': math.sin, 'cos': math.cos, 'tan': math.tan,
    'asin': math.asin, 'acos': math.acos, 'atan': math.atan,
    'sinh': math.sinh, 'cosh': math.cosh, 'tanh': math.tanh,
    'exp': math.exp, 'log': math.log, 'sqrt': math.sqrt,
    'pi': math.pi, 'e': math.e, 'abs': abs, 'pow': pow
}

def eval_V(expr, vval):
    """Safely evaluate V(v) from a string expression at a numeric vval."""
    scope = dict(_SAFE)
    scope['v'] = float(vval)
    return float(eval(expr, {"__builtins__": None}, scope))

# ---------- defaults if inputs are not wired ----------
try:
    V_str
except NameError:
    V_str = "v"

try:
    U
except NameError:
    U = [0.25, 0.5, 1.0, 2.0]

try:
    V
except NameError:
    V = [i*math.pi/8.0 for i in range(-8, 9)]

# ---------- compute grid of points ----------
Pts = []  # rows in V, columns in U

for vv in V:
    Vv = eval_V(V_str, vv)
    Vv2 = Vv * Vv
    cosv = math.cos(vv)
    sinv = math.sin(vv)

    for uu in U:
        u = float(uu)
        denom = 1.0 + (u*u)*Vv2
        if denom == 0.0:
            # avoid division by zero; place a fallback point
            row.append(rg.Point3d(float('nan'), float('nan'), float('nan')))
            continue

        factor = (2.0 * u) / denom

        # Original chosen form:
        # X = (2*u / (1 + u^2 * V(v)^2)) * 1
        # Y = (2*u / (1 + u^2 * V(v)^2)) * (u * cos(v) * V(v))
        # Z = (2*u / (1 + u^2 * V(v)^2)) * (-u * sin(v) * V(v))
        X = factor
        Y = factor * (u * cosv * Vv)
        Z = factor * (-u * sinv * Vv)

        pt = rg.Point3d(X, Y, Z)
        Pts.append(pt)
